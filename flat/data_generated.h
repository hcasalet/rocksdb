// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DATA_H_
#define FLATBUFFERS_GENERATED_DATA_H_

#include "flatbuffers/flatbuffers.h"

struct Row;

struct FBData;

struct Row FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *columns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           verifier.VerifyVectorOfStrings(columns()) &&
           verifier.EndTable();
  }
};

struct RowBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columns) {
    fbb_.AddOffset(Row::VT_COLUMNS, columns);
  }
  explicit RowBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RowBuilder &operator=(const RowBuilder &);
  flatbuffers::Offset<Row> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Row>(end);
    return o;
  }
};

inline flatbuffers::Offset<Row> CreateRow(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> columns = 0) {
  RowBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

inline flatbuffers::Offset<Row> CreateRowDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *columns = nullptr) {
  auto columns__ = columns ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*columns) : 0;
  return CreateRow(
      _fbb,
      columns__);
}

struct FBData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROWS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Row>> *rows() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Row>> *>(VT_ROWS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROWS) &&
           verifier.VerifyVector(rows()) &&
           verifier.VerifyVectorOfTables(rows()) &&
           verifier.EndTable();
  }
};

struct FBDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rows(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Row>>> rows) {
    fbb_.AddOffset(FBData::VT_ROWS, rows);
  }
  explicit FBDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FBDataBuilder &operator=(const FBDataBuilder &);
  flatbuffers::Offset<FBData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FBData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FBData> CreateFBData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Row>>> rows = 0) {
  FBDataBuilder builder_(_fbb);
  builder_.add_rows(rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<FBData> CreateFBDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Row>> *rows = nullptr) {
  auto rows__ = rows ? _fbb.CreateVector<flatbuffers::Offset<Row>>(*rows) : 0;
  return CreateFBData(
      _fbb,
      rows__);
}

#endif  // FLATBUFFERS_GENERATED_DATA_H_
